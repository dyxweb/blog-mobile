## 鉴权
> 因为HTTP是无状态的协议，所谓无状态就是在两次请求之间服务器并不会保存任何的数据，请求之间没有任何相关信息。请求方和响应方间无法维护状态，都是一次性的，它不知道前后的请求发生了什么。

### Session-Cookie
1. 客户端：向服务器发送登录信息用户名/密码来请求登录校验；
2. 服务器：验证登录的信息，验证通过后自动创建 Session（将 Session 保存在内存中，也可以保存在 Redis 中），然后给这个 Session 生成一个唯一的标识字符串会话身份凭证 session_id(通常称为 sid)，并在响应头 Set-Cookie 中设置这个唯一标识符；
3. 客户端：收到服务器的响应后会解析响应头，并自动将 sid 保存在本地 Cookie 中，浏览器在下次 HTTP 请求时请求头会自动附带上该域名下的 Cookie 信息；
4. 服务器：接收客户端请求时会去解析请求头 Cookie 中的 sid，然后根据这个 sid 去找服务端保存的该客户端的 sid，然后判断该请求是否合法；
#### Session-Cookie 的优点
- Cookie 简单易用
- Session 数据存储在服务端，相较于 JWT 方便进行管理，也就是当用户登录和主动注销，只需要添加删除对应的 Session 就可以了，方便管理。
- 只需要后端操作即可，前端可以无感等进行操作。
#### Session-Cookie 的缺点
- 依赖 Cookie，一旦用户在浏览器端禁用 Cookie，就不生效；
- 非常不安全，Cookie 将数据暴露在浏览器中，增加了数据被盗的风险（容易被 CSRF 等攻击）；
- Session 存储在服务端，增大了服务端的开销，用户量大的时候会大大降低服务器性能；
- 对移动端的支持性不友好；
#### Session存储方式
- Redis（推荐）：内存型数据库，以 key-value 的形式存，正合 sessionId-sessionData 的场景；且访问快。
- 内存：直接放到变量里。一旦服务重启就没了。
- 数据库：普通数据库。性能不高。
#### Session 的分布式问题
> 通常服务端是集群，而用户请求过来会走一次负载均衡，不一定打到哪台机器上。那一旦用户后续接口请求到的机器和他登录请求的机器不一致，或者登录请求的机器宕机，session就会失效。

- 从存储角度，把 session 集中存储。用独立的 Redis 或普通数据库可以把 session 都存到一个库里。(优先使用此方案,从分布角度处理相当于阉割了负载均衡，而且没有解决用户请求的机器宕机的问题)
- 从分布角度，让相同 IP 的请求在负载均衡时都打到同一台机器上。以 nginx 为例，可以配置 ip_hash 来实现。
### Token
1. 客户端：输入用户名和密码请求登录校验；
2. 服务器：收到请求，去验证用户名与密码；验证成功后，服务端会签发一个 Token 并把这个 Token 发送给客户端；
3. 客户端：收到 Token 以后需要把它存储起来，web 端一般会放在 localStorage 或 Cookie 中，移动端原生 APP 一般存储在本地缓存中；
4. 客户端发送请求：向服务端请求 API 资源的时候，将 Token 通过 HTTP 请求头 Authorization 字段或者其它方式发送给服务端；
5. 服务器：收到请求，然后去验证客户端请求里面带着的 Token ，如果验证成功，就向客户端返回请求的数据，否则拒绝返还（401）；
#### Token 的优点
- 服务端无状态化、可扩展性好：Token 机制在服务端不需要存储会话（Session）信息，因为 Token 自身包含了其所标识用户的相关信息，这有利于在多个服务间共享用户状态；
- 支持 APP 移动端设备；
- 安全性好： 有效避免 CSRF 攻击（因为不需要 Cookie）；
- 支持跨程序调用：因为 Cookie 是不允许跨域访问的，而 Token 则不存在这个问题；
#### Token 的缺点：
- 配合：需要前后端配合处理；
- 占带宽：正常情况下比 sid 更大，消耗更多流量，挤占更多宽带；
- 性能问题：虽说验证 Token 时不用再去访问数据库或远程服务进行权限校验，但是需要对 Token 加解密等操作，所以会更耗性能；
- 有效期短：为了避免 Token 被盗用，一般 Token 的有效期会设置的较短，所以就有了 Refresh Token；
#### Refresh Token
1. 客户端： 输入用户名和密码请求登录校验；
2. 服务端： 收到请求，验证用户名与密码；验证成功后，服务端会签发一个 Access Token 和 Refresh Token 并返回给客户端；
3. 客户端： 把 Access Token 和 Refresh Token 存储在本地；
4. 客户端发送请求： 请求数据时，携带 Access Token 传输给服务端；
5. 服务端：
  - 验证 Access Token 有效：正常返回数据
  - 验证 Access Token 过期：拒绝请求
6. 客户端 (Access Token 已过期) ： 则重新传输 Refresh Token 给服务端；
7. 服务端 (Access Token 已过期) ： 验证 Refresh Token ，验证成功后返回新的 Access Token 给客户端；
8. 客户端： 重新携带新的 Access Token 请求接口；
### Token 和 Session-Cookie 的区别
> Session-Cookie 和 Token 有很多类似的地方，但是 Token 更像是 Session-Cookie 的升级改良版。

- 存储地不同：Session 一般是存储在服务端；Token 是无状态的，一般由前端存储；
- 安全性不同：Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击；
- 支持性不同： Session-Cookie 认证需要靠浏览器的 Cookie 机制实现，如果遇到原生 NativeAPP 时这种机制就不起作用了，或是浏览器的 Cookie 存储功能被禁用，也是无法使用该认证机制实现鉴权的；而 Token 验证机制丰富了客户端类型。
### JWT（JSON Web Token）鉴权
> 上述的Token形式服务端验证客户端发送过来的 Token 时，需要查询数据库获取用户基本信息，然后验证 Token 是否有效；这样每次请求验证都要查询数据库，增加了查库带来的延迟等性能消耗；JWT就是登录成功后将相关用户信息组成 JSON 对象，然后对这个对象进行某种方式的加密，返回给客户端；客户端在下次请求时带上这个 Token；服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。

#### JWT 的优点
- 不需要在服务端保存会话信息（RESTful API 的原则之一就是无状态），所以易于应用的扩展，即信息不保存在服务端，不会存在 Session 扩展不方便的情况；
- JWT 中的 Payload 负载可以存储常用信息，用于信息交换，有效地使用 JWT，可以降低服务端查询数据库的次数。
#### JWT 的缺点
- 加密问题：JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
- 到期问题：由于服务器不保存 Session 状态，因此无法在使用过程中废止某个 Token，或者更改 Token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
### JWT 和 Token的区别
> jwt和token区别主要体现在接收的信息是否需要进入数据库查询信息。

### 单点登录
#### 同域下的 SSO（主域名相同）
> 当百度网站存在两个相同主域名下的贴吧子系统 tieba.baidu.com 和网盘子系统 pan.baidu.com 时，以下为他们实现 SSO 的步骤：

1. 客户端：用户访问某个子系统时（例如 tieba.baidu.com），如果没有登录，则跳转至 SSO 认证中心提供的登录页面进行登录；
2. 服务端：登录认证后，服务端把登录用户的信息存储于 Session 中，并且附加在响应头的 Set-Cookie 字段中，设置 Cookie 的 Domain 为 .baidu.com ；
3. 客户端：再次发送请求时，携带主域名 Domain 下的 Cookie 给服务器，此时服务端就可以通过该 Cookie 来验证登录状态了；
#### 跨域下的 SSO（主域名不同）
> 购物网站天猫 (tmall.com) 和淘宝 (taobao.com) 中，利用CAS（Central Authentication Service）中央授权服务只需要登录其中某一个系统，另外一个系统打开后就会默认登录。

![单点登录](./img/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95.png)
1. 客户端：开始访问系统 A；
2. 系统A：发现用户未登录，重定向至 CAS 认证服务（sso.com），同时 URL 地址参数携带登录成功后回跳到系统 A 的页面链接（sso.com/login?redir…）
3. CAS认证服务：发现请求 Cookie 中没有携带登录的票据凭证（TGC），所以 CAS 认证服务判定用户处于 未登录 状态，重定向用户页面至 CAS 的登录界面，用户在 CAS 的登录页面上进行登录操作。
4. 客户端：输入用户名密码进行 CAS 系统认证；
5. CAS 认证服务：校验用户信息，并且 生成 TGC 放入自己的 Session 中，同时以 Set-Cookie 形式写入 Domain 为 sso.com 的域下 ；同时生成一个 授权令牌 ST (Service Ticket) ，然后重定向至系统 A 的地址，重定向的地址中包含生成的 ST（重定向地址：www.taobao.com?token=ST-345678）
6. 系统A：拿着 ST 向 CAS 认证服务发送请求，CAS 认证服务验证票据 (ST) 的有效性。验证成功后，系统 A 知道用户已经在 CAS 登录了（其中的 ST 可以保存到 Cookie 或者本地中），系统 A 服务器使用该票据 (ST) 创建与用户的会话，称为局部会话，返回受保护资源；
7. 客户端：开始访问系统 B；
8. 系统B：发现用户未登录，重定向至 SSO 认证服务，并将自己的地址作为参数传递，并附上在 sso.com 域下的 cookie 值是第五步生成的 TGC；
9. CAS 认证服务：CAS 认证服务中心发现用户已登录，跳转回系统 B 的地址，并附上票据 (ST)；
10. 系统B：拿到票据 (ST)，去 CAS 认证服务验证票据 (ST) 的有效性。验证成功后，客户端也可以跟系统 B 通信。
#### CAS 一般提供四个接口：
- /login：登录接口，用于登录到中央授权服务。
- /logout：登出接口，用于从中央授权服务中登出。
- /validate：用于验证用户是否登录中央授权服务。
- /serviceValidate：用于让各个 Service 验证用户是否登录中央授权服务。
### 第三方登录
1. a.com 的运营者需要在微信开放平台注册账号，并向微信申请使用微信登录功能。
2. 申请成功后，得到申请的 appid、appsecret。
3. 用户在 a.com 上选择使用微信登录。
4. 这时会跳转微信的 OAuth 授权登录，并带上 a.com 的回调地址。
5. 用户输入微信账号和密码，登录成功后，需要选择具体的授权范围，如：授权用户的头像、昵称等。
6. 授权之后，微信会根据拉起 a.com?code=123 ，这时带上了一个临时票据 code。
7. 获取 code 之后，a.com 会拿着 code 、appid、appsecret，向微信服务器申请 token，验证成功后，微信会下发一个 token。
8. 有了 token 之后，a.com 就可以凭借 token 拿到对应的微信用户头像，用户昵称等信息了。
9. a.com 提示用户登录成功，并将登录状态写入 Cooke，以作为后续访问的凭证。
### 唯一登录
> 用户只能在一个设备上登录，禁止用户重复登录。

![唯一登录](./img/%E5%94%AF%E4%B8%80%E7%99%BB%E5%BD%95.png)
- 用户在客户端 A 操作：
  1. 输入账号请求登录接口；
  2. 后端生成对应 Token 并且返回给客户端 A，并且在服务端保存一个登录状态；
  3. 客户端A 保存 Token，并且每次请求都在 header 头中携带对应的 Token；
- 用户在客户端 B 操作：
  1. 突然用户在客户端 B 上开始登录操作，我们会发现，步骤和在客户端A上面的操作几乎是一致的；
  2. 只是后端在生成新的 Token 时，要先验证登录状态，然后再生成对应新的 Token；
  3. 客户端A再操作时发现Token过期提示重新登录。
### 扫码登录
![扫码登录](./img/%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95.png)
- 待扫码阶段：
  1. PC端：打开某个网站 (如taobao.com) 或者某个 APP (如微信) 的扫码登录入口；就会携带 PC 端的设备信息向服务端发送一个获取二维码的请求；
  2. 服务端：服务器收到请求后，随机生成一个 UUID 作为二维码 ID，并将 UUID 与 PC 端的设备信息 关联起来存储在 Redis 服务器中，然后返回给 PC 端；同时设置一个过期时间，在过期后，用户登录二维码需要进行刷新重新获取。
  3. PC 端：收到二维码 ID 之后，将二维码 ID 以 二维码的形式 展示，等待移动端扫码。并且此时的 PC 端开始轮询查询二维码状态，直到登录成功。
如果移动端未扫描，那么一段时间后二维码会自动失效。
- 已扫码待确认阶段：
  1. 手机端：打开手机端对应已登录的 APP (微信或淘宝等)，开始扫描识别 PC 端展示的二维码；
移动端扫描二维码后，会自动获取到二维码 ID，并将移动端登录的信息凭证（Token）和二维码 ID 作为参数发送给服务端，此时手机必须是已登录（使用扫描登录的前提是移动端的应用为已登录状态，这样才可以共享登录态）。
  2. 服务端：
收到手机端发来的请求后，会将 Token 与二维码 ID 关联，为什么需要关联呢？因为，当我们在使用微信时，移动端退出时，PC 端也应该随之退出登录，这个关联就起到这个作用。然后会生成一个临时 Token，这个 Token 会返回给移动端，一次性 Token 用作确认时的凭证。
- 已确认阶段：
  1. 手机端：收到确认信息后，点击确认按钮，移动端携带上一步中获取的 临时 Token 发送给服务端校验；
  2. 服务端：服务端校验完成后，会更新二维码状态，并且给 PC 端生成一个 正式的 Token，后续 PC 端就是持有这个 Token 访问服务端。
  3. PC端：轮询到二维码状态为已登录状态，并且会获取到了生成的 Token，完成登录，后续访问都基于 Token 完成。
