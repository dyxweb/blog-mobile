## diff
> Diff操作本身也会带来性能损耗，React文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为O(n^3)，其中n是树中元素的数量。如果在React中使用了该算法，那么展示1000个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂，无法接受。

### 降低算法复杂度，React的diff会预设三个限制
1. 只对同级元素进行Diff，不做跨级比较。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用它，React只会简单地考虑同层级节点的位置变换，而对于不同层级的节点，只有创建和删除操作。
2. 两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。
3. 开发者可以通过key属性来告诉react哪些子元素在不同的渲染下能保持稳定。
### O(n^3) => O(n)
- 每个节点都要去和另一棵树的全部节点对比一次，这就是 n 了，如果找到有变化的节点，执行插入、删除、修改也是 n 的复杂度。所有的节点都是这样，再乘以 n，所以是 O(n * n * n) 的复杂度。
- 有了上述的限制这样只要遍历一遍，对比一下 type 就行了，是 O(n) 的复杂度，而且 type 变了就不再对比子节点。因为 vdom 中记录了关联的 dom 节点，执行 dom 的增删改也不需要遍历，是 O(1)的，整体的 diff 算法复杂度就是 O(n) 的复杂度。
### diff的思路
1. 当根节点为不同类型的元素时，React会拆卸原有的树并且建立起新的树，这大大减少了Diff过程中冗余的递归操作。
2. 当对比两个相同类型的React元素时，React会保留DOM节点，仅比对及更新有改变的属性。
3. 列表形式的子元素比较，React引入了key属性。当子元素拥有key时，React使用key来匹配原有树上的子元素以及最新树上的子元素，如果key不同则会拆卸原有的 key节点并且建立起新的key节点。
### Diff算法是一种对比算法
> 对比两者是旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准地更新真实DOM，进而提高效率。

- 使用虚拟DOM算法的损耗计算
> 总损耗 = 虚拟DOM增删改(与Diff算法效率有关) + 真实DOM差异增删改 + (较少的节点)排版与重绘

- 直接操作真实DOM的损耗计算
> 总损耗 = 真实DOM完全增删改 + (可能较多的节点)排版与重绘

### 为什么虚拟DOM快
> 减弱频繁的大面积重绘引发的性能问题。

- 虚拟DOM进行频繁修改，然后**一次性比较并修改**真实DOM中需要改的部分，最后在真实DOM中进行排版与重绘，减少排版重绘的次数，真实DOM频繁排版与重绘的效率是相当低的。
- 虚拟DOM有效降低大面积(真实DOM节点)的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部。
### 视图更新流程
- 组件渲染生成一棵新的虚拟dom树(render方法)。
- 新旧虚拟dom树对比，找出变动的部分(常说的diff算法)。
- 根据改变的虚拟dom树更新到真实dom上。
### vue与react的diff比较
- vue和react的diff算法，都是忽略跨级比较，只做同级比较。
- vue和react的diff算法，两个不同类型的元素会产生出不同的树，不会尝试复用。
- vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。
- vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。


