## 埋点
> 可以对用户行为或事件进行捕获，可以分析订单转化或者不同交互方式的优劣比较。

### ajax埋点上报
> 和后端约定接口进行数据上报。一般而言埋点域名并不是当前域名，因此请求会存在跨域风险，且如果ajax配置不正确可能会浏览器拦截。

```
function buryingPointAjax(data) {
  return new Promise((resolve, reject) => {
    // 创建ajax请求
    const xhr = new XMLHttpRequest();
    // 定义请求接口
    xhr.open("post", '/buryingPoint', true);
    // 发送数据
    xhr.send(data);
  });
}

// 上报info对象
buryingPointAjax(info);
```
### img埋点上报
> 如果使用ajax上报的话会存在跨域的问题，可以通过一些支持跨域的标签去实现数据上报功能。script，link，img是我们上报的数据的最好对象，如果需要请求script和link，我们需要将标签挂载到页面上，而反复操作dom会造成页面性能受影响，而且载入js/css资源还会阻塞页面渲染，影响用户体验。img标签加载并不需要挂载到页面上，基于js去new image()，设置其src之后就可以直接请求图片。通常埋点上报会使用gif图。

```
const img = new Image();
img.src = "https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/MaskGroup.13dfc4f1.png";
```
### Navigator.sendBeacon埋点上报
> Navigator.sendBeacon是目前通用的埋点上报方案，Navigator.sendBeacon方法接受两个参数，第一个参数是目标服务器的 URL，第二个参数是所要发送的数据（可选），可以是任意类型（字符串、表单对象、二进制对象等等）。相较于img标签，使用navigator.sendBeacon会更规范，数据传输上可传输资源类型会更多。对于ajax在页面卸载时上报，ajax有可能没上报完，页面就卸载了导致请求中断，因此ajax处理这种情况时必须作为同步操作。sendBeacon是异步的，不会影响当前页到下一个页面的跳转速度，且不受同域限制。这个方法还是异步发出请求，但是请求与当前页面脱离关联，作为浏览器的任务，因此可以保证会把数据发出去，不拖延卸载流程。

### 总结
- 不推荐使用ajax。
- 如果考虑兼容性的话，img是不二之选。
- 目前最合适的方案是navigator.sendBeacon，不仅是异步的，而且不受同域限制，而且作为浏览器的任务，因此可以保证会把数据发出去，不影响页面卸载。
### 常见埋点行为
- 点击事件触发埋点
```
function clickButton(url, data) {
  navigator.sendBeacon(url, data)
}
```
- 页面停留时间触发埋点
```
let url = ''// 上报地址
let startTime = Date.now()
let currentTime = ''
router.beforeEach((to, from, next) => { 
  if (to) {
    currentTime = Date.now()
    stayTime = parseInt(currentTime - startTime)
    navigator.sendBeacon(url, {time: stayTime})
    startTime = Date.now()
  }
})
```
- 错误监听埋点
    - JS异常与静态资源加载异常
    ```
    window.addEventListener('error', (error) => { 
      if (error.message) { 
        navigator.sendBeacon(url, { error: error.message, text: 'js执行异常' })
      } else { 
        navigator.sendBeacon(url, { error: error.filename, text: '资源加载异常' })
      } 
    }, true)
    ```
    - 请求错误捕获
    ```
    axios.interceptors.response.use(
      (response) => {
        if (response.code == 200) {
          return Promise.resolve(response);
        } else {
          return Promise.reject(response);
        }
      },
      (error) => {
        // 返回错误逻辑
        navigator.sendBeacon(url, { error: error, text: '请求错误异常' })
      }
    );
    ```