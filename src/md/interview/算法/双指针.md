## 双指针
### [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)
- 双层循环
> 所有区间计算结果的比较，取最大的值。

```
const maxArea = function(height) {
  let max = 0
  for(let i = 0; i < height.length; i++) {
    for(let j = i + 1; j < height.length; j++) {
      currentValue = (j - i) * Math.min(height[i], height[j])
      if (max < currentValue) {
        max = currentValue
      }
    }
  }
  return max
};
```
- [双指针](https://mp.weixin.qq.com/s/Nm4tgudd7RB3dxCy8FP8BQ)
> 从起始和结束两个指针向中间压缩，比较区间的值，取最大的值。

```
const maxArea = function(height) {
  let max = 0
  let left = 0
  let right = height.length
  while(left < right) {
    currentValue = (right - left) * Math.min(height[left], height[right])
    if (max < currentValue) {
      max = currentValue
    }
    if (height[left] < height[right]) {
      left++
    } else {
      right--
    }
  }
  return max
};
```
### [判断字符串是否为某一个字符串的子序列(顺序一致即可，不一定要是连续的)](https://leetcode-cn.com/problems/is-subsequence/)
> 利用双指针遍历两个字符串，整串的指针移动，当匹配时子串的的指针向后移动，最后比较子串的指针index与子串的长度比较。

```
const isSubsequence = (s, t) => {
  let i = 0; // 子串的指针
  let j = 0; // 整串的指针
  while (i < s.length && j < t.length) {
    if (s[i] == t[j]) i++;
    j++;
  }
  return i == s.length;
}
```
### [删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)
> 利用快慢指针，将后面较大的数值移动到前面，保持前面的数组为有序数组。

```
const removeDuplicates = (nums) => {
  if (nums.length <= 1) return nums.length;
  let slow = 0, quick = 0;
  while (quick < nums.length) {
    while (nums[slow] === nums[quick]) quick++;
    if (nums[slow] !== nums[quick] && quick < nums.length) {
      slow++;
      nums[slow] = nums[quick];
      quick++;
    }
  }
  return slow + 1;
};
```
### 删除数组的重复项,返回数组的长度。不要使用额外的数组空间，必须在原地修改数组
> 慢指针是i，快指针是j，如果nums[i] 等于 nums[j] 说明是相同的元素，j继续走，i还在原位，如果nums[i] 不等于 nums[j] 说明是不相同的元素，那么nums[i++] = nums[j]，j继续向前走，就相当于i指针保证它和它前面的数字都是不重复的，j就是一个遍历器。

```
const removeDuplicates = (nums) => {
  let i = 0;
  for(let j = 1; j < nums.length; j++) {
    if(nums[j] !== nums[i]) {
      nums[i+1] = nums[j];
      i++;
    }
  }
  return i + 1
};
```
### 是否为回文字符串
> 双指针，头尾向中间靠拢

```
const isPalindrome = (s) => {
  s = s.replace(/[^\w]/g, '').toLowerCase();
  let leftPointer = 0;
  let rightPointer = s.length - 1;
  while(rightPointer > leftPointer) {
    if(s[leftPointer++] === s[rightPointer--]) {
      continue;
    } else {
      return false;
    }
  }
  return true;
};
```
### 数组中字符串翻转
> 利用首尾双指针进行数组值替换

```
const reverseString = (s) => {
  let l = 0 ;
  let r = s.length - 1;
  while(l < r) {
    [s[l], s[r]] = [s[r], s[l]];
    l++; r--;
  }
  return s;
};
```
### 给定一个数组将所有0移动到数组的末尾，同时保持非零元素的相对顺序。
> 用快慢指针来交换数组项的位置。

```
const moveZeroes = (nums) => {
  let i = j = 0;
  while(i < nums.length) {
    if(nums[i] !== 0) {
      // 交换位置，将非0的值前移
      [nums[i], nums[j]] = [nums[j], nums[i]];
      j++;
    }
    i++;
  }
  return nums
};
```
