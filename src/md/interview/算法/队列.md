## 队列
### 约瑟夫环问题
> 一个数组存放了 100 个数据 0-99，要求每隔两个数删除一个数，到末尾时再循环至开头继续进行，求最后一个被删除的数字。

1. 创建队列，将 0 到 99 的数字入队。
2. 循环队列，依次出列队列中的数字，对当前出队的数字进行计数 index + 1。
3. 判断当前出列的 index % 3 是否等于 0，如果不等于 0 则再次入队。
4. 直到队列的长度为 1，退出循环，返回队列中的数字。
```
function ring(arr) {
  const queue = new Queue();
  arr.forEach(v => queue.enqueue(v));
  let index = 0;
  while(queue.size() > 1) {
    const item = queue.dequeue();
    if (++index % 3 !== 0) {
      queue.enqueue(item);
    }
  }
  return queue.head();
}
```
### 斐波那契数列
> 指的是这样一个数列：0、1、1、2、3、5、8、13、21、34。

```
function fiboSequence(num) {
  if (num < 2) return num;
  const queue = [];
  queue.push(0);
  queue.push(1);
  for(let i = 2; i < num; i++) {
    const len = queue.length;
    queue.push(queue[len - 2] + queue[len  - 1]);
  }
  return queue;
}
```
### 最近的请求次数
```
const RecentCounter = () => {
  // 初始化队列
  this.q = [];
};

// 输入 inputs = [[],[1],[100],[3001],[3002]] 请求间隔为 3000ms
// 输出 outputs = [null,1,2,3,3]   

// 时间复杂度 O(n) n为剔出老请求的长度
// 空间复杂度 O(n) n为最近请求的次数
RecentCounter.prototype.ping = function (t) {
  // 如果传入的时间小于等于最近请求的时间，则直接返回0
  if (!t) return null

  // 将传入的时间放入队列
  this.q.push(t);

  // 如果队头小于 t - 3000 则剔除队头
  while (this.q[0] < t - 3000) {
    this.q.shift();
  }

  // 返回最近请求的次数
  return this.q.length;
};
```