## 字典
### 两数之和
```
// nums = [2, 7, 11, 15] target = 9

// 时间复杂度O(n) n为nums的length
// 空间复杂度O(n)
const twoSum = function (nums, target) {
  // 建立一个字典数据结构来保存需要的值
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    // 获取当前的值，和需要的值
    const n = nums[i];
    const n2 = target - n;
    // 如字典中有需要的值，就匹配成功
    if (map.has(n2)) {
      return [map.get(n2), i];
    } else {
    // 如没有，则把需要的值添加到字典中
      map.set(n, i);
    }
  }
};
```
### 两个数组的交集
```
// nums1 = [1,2,2,1], nums2 = [2,2]
// 输出：[2]

// 时间复杂度 O(m + n) m为nums1长度 n为nums2长度
// 空间复杂度 O(m) m为交集的数组长度
const intersection = (nums1, nums2) => {
  // 创建一个字典
  const map = new Map();
  // 将数组1中的数字放入字典
  nums1.forEach(n => map.set(n, true));
  // 创建一个新数组
  const res = [];
  // 将数组2遍历 并判断是否在字典中
  nums2.forEach(n => {
    if (map.has(n)) {
      res.push(n);
      // 如果在字典中，则删除该数字
      map.delete(n);
    }
  })
  return res;
};
```
### 最小覆盖字串
```
// 输入：s = "ADOBECODEBANC", t = "ABC"
// 输出："BANC"

// 时间复杂度 O(m + n) m是t的长度 n是s的长度
// 空间复杂度 O(k) k是字符串中不重复字符的个数
const minWindow = function (s, t) {
  // 定义双指针维护一个滑动窗口
  let l = 0;
  let r = 0;

  // 建立一个字典
  const need = new Map();
  //  遍历t
  for (const c of t) {
    need.set(c, need.has(c) ? need.get(c) + 1 : 1)
  }
  let needType = need.size
  // 记录最小子串
  let res = ""

  // 移动右指针
  while (r < s.length) {
    // 获取当前字符
    const c = s[r];
    // 如果字典里有这个字符
    if (need.has(c)) {
      // 减少字典里面的次数
      need.set(c, need.get(c) - 1);
      // 减少需要的值
      if (need.get(c) === 0) needType -= 1;
    }
    // 如果字典中所有的值都为0了 就说明找到了一个最小子串
    while (needType === 0) {
      // 取出当前符合要求的子串
      const newRes = s.substring(l, r + 1)
      // 如果当前子串是小于上次的子串就进行覆盖
      if (!res || newRes.length < res.length) res = newRes;
      // 获取左指针的字符
      const c2 = s[l];
      // 如果字典里有这个字符
      if (need.has(c2)) {
        // 增加字典里面的次数
        need.set(c2, need.get(c2) + 1);
        // 增加需要的值
        if (need.get(c2) === 1) needType += 1;
      }
      l += 1;
    }
    r += 1;
  }
  return res;
};
```