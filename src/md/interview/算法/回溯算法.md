## 回溯算法
> 算法设计中的一种思想，一种渐进式寻找并构建问题解决方式的策略，会先从一个可能的动作开始解决问题，如不行，就回溯选择另外一个动作，直到找到一个解。

### 全排列
```
// 输入 [1, 2, 3]
// 输出 [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]

// 时间复杂度 O(n!) n! = 1 * 2 * 3 * ··· * (n-1) * n;
// 空间复杂度 O(n)

var permute = function (nums) {
  // 存放结果
  const res = [];
  const backTrack = (path) => {
    // 递归结束条件 
    if (path.length === nums.length) {
      res.push(path);
      return;
    }
    // 遍历传入数组
    nums.forEach(n => {
      // 如果子数组中有这个元素就是死路，需要回溯回去走其他路
      if (path.includes(n)) return;
      // 加入到子数组里
      backTrack(path.concat(n));
    })
  }

  backTrack([]);
  return res;
};
```
### 子集
```
// 输入 [1, 2, 3]
// 输出 [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]

// 时间复杂度 O(2 ^ N) 每个元素都有两种可能
// 空间复杂度 O(N)

var subsets = function (nums) {
  // 存放结果数组
  const res = [];
  const backTrack = (path, l, start) => {
    // 递归结束条件
    if (path.length === l) {
      res.push(path);
      return;
    }
    // 遍历输入的数组长度 起始位置是start
    for (let i = start; i < nums.length; i++) {
      // 递归调用 需要保证子集的有序, start为 i+1
      backTrack(path.concat(nums[i]), l, i + 1);
    }
  };

  // 遍历输入数组长度
  for (let i = 0; i <= nums.length; i++) {
    // 传入长度 起始索引
    backTrack([], i, 0);
  }
  return res
};
```