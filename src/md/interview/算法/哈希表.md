## 哈希表 
### 哈希表 + 计数类型
#### 给定一个整数数组，判断是否存在重复元素。
> 根据元素出现的次数来判断是是否有重复元素。

```
const containsDuplicate = (nums) => {
  let map = new Map();
  for(let i of nums) {
    if(map.has(i)) {
      return true;
    } else {
      map.set(i, 1);
    }
  }
  return false;
};
```
#### 返回字符串中第一个唯一字符的索引
> 遍历字符串,用一个对象{}来记数，出现过一次就+1，遍历完毕，再次遍历字符串，看它们在之前记录的对象里的值，是否是1，是就返回下标，不是返回-1。

```
const firstUniqChar = (s) => {
  const map = {};
  for(let v of s) {
    map[v] = (map[v] || 0) + 1;
  }
  for(let i = 0; i < s.length; i++) {
    if(map[s[i]] === 1) {
      return i;
    }
  }
  return -1;
};
```
#### 判断是否为有效的字母异位词(两个字符串s和t，若s和t中每个字符出现的次数都相同，则称s和t互为字母异位词)
> 判断两个字符串长度是否相同，如果相同根据长度进行循环，用一个对象来计数，字符串s对应的字符加1，字符串t对应的字符减1，最后所有的value都为0，表示两个字符串的字符出现次数相同。

```
const isAnagram = (s, t) => {
  const sLen = s.length;
  const tLen = t.length;
  if(sLen !== tLen) {
    return false;
  }
  const obj = {};
  for(let i = 0; i < sLen; i++) {
    const currentS = s[i];
    const currentT = t[i];
    obj[currentS] ? obj[currentS]++ : obj[currentS] = 1;
    obj[currentT] ? obj[currentT]-- : obj[currentT] = -1;
  }
  return Object.values(obj).every(v => v === 0);
};
```
#### 给定一个大长度n的数组，找到在数组中出现次数大于n/2的元素。
```
const majorityElement = (nums) => {
  const map = {};
  const n = nums.length >> 1;   // >> 是右移运算符，意思是除以2
  for(let i = 0; i < nums.length; i++) {
    map[nums[i]] = map[nums[i]] !== undefined ? map[nums[i]] + 1 : 1;
    if(map[nums[i]] > n) {
      return nums[i];
    }
  }
}
```
### 哈希表 + 映射功能
#### (两数之和(给定一个整数数组nums和一个整数目标值target，在该数组中找出和为目标值target的那 两个整数，并返回它们的数组下标))[https://leetcode-cn.com/problems/two-sum/]
- 用 hashMap 存储遍历过的元素和对应的索引。每遍历一个元素，看看 hashMap 中是否存在满足要求的目标数字。

```
const twoSum = (nums, target) => {
  const map = new Map();
  for(let i = 0, len = nums.length; i < len; i++) {
    if(map.get(nums[i]) !== undefined) {
      return [map.get(nums[i]), i];
    } else {
      // 存储满足和当前值相加结果匹配的数值
      map.set(target - nums[i], i);
    }
  }
  return [];
};
```
- 双层for循环
```
const twoSum = (nums, target) => {
  for(let i = 0; i< nums.length; i++) {
    for(let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j]
      }
    } 
  }
};
```
#### 两个数组的交集，返回所有交集的数字
- set实现，复杂度较高
```
const intersection = (nums1, nums2) => {
  return [...new Set(nums1)].filter(item => new Set(nums2).has(item))
};
```
- map实现
> 用一个对象去存nums1数组里的每一项，类似map[nums1[i]] = true，然后去遍历nums2，如果在map中已经有的值，类似map[nums2[i]], 就把它push到一个数组里，并且将map[nums2[i]]设为false，后面有相同的值就不push到数组了。

```
const intersection = (nums1, nums2) => {
  const map = {};
  const ret = [];
  for(let i = 0; i < nums1.length; i++) {
    map[nums1[i]] = true;
  }
  for(let i = 0; i < nums2.length; i++) {
    if(map[nums2[i]]) {
      ret.push(nums2[i])
      map[nums2[i]] = false;
    }
  }
  return ret;
};
```