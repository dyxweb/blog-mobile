## 发布订阅模式
> 发布订阅模式中，包含发布者，事件调度中心，订阅者三个角色。实现的EventHandler的每一个实例就是一个事件调度中心，发布者和订阅者是松散耦合的，互不关心对方是否存在，他们关注的是事件本身。发布者借用事件调度中心提供的emit方法进行事件触发，而订阅者则通过on进行事件注册。可类比于DOM事件中的dispatchEvent和addEventListener。

### demo
> EventBus实现发布和订阅逻辑。

```
type EventHandler = (data?: any) => void;

class EventEmitter {
  handlersMapping: {
    [key: string]: Array<EventHandler>;
  } = {};

  // 注册事件和处理函数
  on(type: string, handler: EventHandler) {
    let handlers = this.handlersMapping[type];
    if (!handlers) {
      handlers = this.handlersMapping[type] = [];
    }
    handlers.push(handler);
  }

  // 销毁事件和处理函数
  off(type: string, handler: EventHandler) {
    let handlers = this.handlersMapping[type] || [];
    if (!handler) {
      // 没有传入要销毁的方法时，清空时间对应所有方法
      this.handlersMapping[type] = [];
    } else {
      const targetIndex = handlers.findIndex((handlerItem: EventHandler) => handlerItem === handler);
      if (targetIndex !== -1) {
        handlers.splice(targetIndex, 1);
      }
    }
  }

  // 触发某事件所有回调并带参数
  emit(type: string, payload?: any) {
    let handlers = this.handlersMapping[type] || [];
    handlers.forEach(handler => handler(payload));
  }
}

export default new EventEmitter();

// 内部组件进行监听某个事件执行在内部组件中注册处理函数，在全局组件中满足条件时触发内部组件所监听的方法
const dyxtest = () => {}
useEffect(() => {
  eventBus.on("dyxtest", dyxtest);
  return () => {
    eventBus.off("dyxtest", dyxtest);
  };
}, []);

// 全局组件触发
eventBus.emit("dyxtest");
```

