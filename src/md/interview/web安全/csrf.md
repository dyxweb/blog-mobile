## crsf
> CSRF（Cross-site request forgery）跨站请求伪造 攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

### 攻击流程
1. 受害者登录a.com，并保留了登录凭证（Cookie）
2. 攻击者引诱受害者访问了b.com
3. b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie
4. a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求
5. a.com以受害者的名义执行了act=xx
6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。
### 攻击形式
1. csrf可以通过get请求，即通过访问img的页面后，浏览器自动访问目标地址，发送请求
2. 设置一个自动提交的表单发送post请求
3. 使用a标签，用户点击链接就会触发
### 攻击特点
1. 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
2. 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。
3. 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
4. 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。
### crsf预防
1. Referrer (阻止不明外域的访问 origin 请求头同理)
> HTTP 请求头 Referrer 字段是浏览器默认带上，含义是发送请求的页面地址，所以后端只要通过 Referrer 做白名单判断就能防这种常见的CSRF攻击。

  - 在浏览器环境下，Referrer 是浏览器自己带上的，js 是改不了 Rerferrer，所以是不能被伪造和篡改的。
  - 浏览器插件是可以改 Referrer 的，但是浏览器插件攻击不属于 CSRF 攻击范畴，如果用户浏览器都已经被安装了黑客插件了就有更方便的攻击方法，但是不可能在所有用户浏览器都安装上黑客的插件。
  - 通过网关或者抓包可以修改 Referrer 的，这是中间人攻击，也不属于 CSRF 攻击范畴。防中间人攻击用 HTTPS。
  - 黑客通过自己后台代理，请求发到黑客自己的后台，黑客后台修改 Referrer 再转发到相册后台，可以修改 Referrer，但不可行，请求发送到黑客自己后台不会带上相册的 Cookie，登录态校验通不过，敏感操作做不了。
2. Token (提交时附加本域信息)
> 在本站发起的请求中，加一个攻击者无法获取的token，也可以区别出正常请求和恶意请求。这个token和浏览器自动携带的cookie不一样，是需要前端手动带上的。但这种方案对服务器压力较大，需要维护一个session对收到的token做校验。

3. 双重Cookie验证
> 相较于与token，双重cookie不需要服务器做额外扩容。只需要在请求中加一个额外的字段，其值和cookie一致。攻击者没法获取到cookie，只是在发起请求时会携带。在服务端收到请求时，如果没有和cookie值一样的额外字段，就可以认为是来自恶意网站。

4. Samesite Cookie，SameSite可以设置为三个值，Strict、Lax和None。表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击。
  - 在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带 Cookie，在其他网站请求都不能。
  - 在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。
  - 在None模式下，也就是默认模式，请求会自动携带上 Cookie。
5. 通用方式
  - 当前用户打开其他用户填写的链接时，需告知风险；
  - 不直接使用用户上传的图片，先在自己的服务器转存；

